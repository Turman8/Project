# Pynq-Z2 End-to-End Deployment Blueprint

This document summarizes the recommended steps for turning the wavelet + CNN arrhythmia classifier into a deployable product on the Pynq-Z2 platform. It highlights the separation of responsibilities between the processing system (PS, ARM/Linux side) and the programmable logic (PL, FPGA fabric), and it shows how to connect real ECG acquisition, preprocessing, inference, and user experience layers.

## 1. Overall System Architecture

```
ECG Sensor Front-End ──> Analog Front-End (AFE) ──> PS Data Acquisition ──┬─> Preprocessing
                                                                    │
                                                                    └─> PL CNN Inference IP ──> PS Post-Processing ──> UX / Front-End
```

- **Sensor & AFE**: Use an ECG front-end module (e.g., ADAS1000, ADS1292R) that digitizes the analog signal and streams samples via SPI or I²C to the Zynq PS.
- **PS (ARM/Linux)**: Runs Pynq Ubuntu, handles sensor drivers, buffering, wavelet preprocessing, orchestration, and user applications.
- **PL (FPGA fabric)**: Hosts the exported `ecg_cnn_inference` IP core (64×300×3 input tensor → NUM_CLASSES probability vector).
- **Front-End**: Can be a lightweight web dashboard hosted on the PS or off-board PC that visualizes ECG traces and inference results in near real-time.

## 2. Processing System Responsibilities

1. **Device bring-up**
   - Integrate Linux drivers or bare-metal drivers for the selected ECG AFE (SPI, I²C, or UART).
   - Use DMA (AXI-DMA or AXI-Stream) to move sampled data into PS memory without stalling the CPU.

2. **Signal conditioning and denoising**
   - Apply digital filters (50/60 Hz notch, baseline wander removal, and band-pass filtering) using `scipy.signal` or custom C implementations.
   - Maintain a circular buffer storing the last few seconds of ECG samples.

3. **Beat segmentation**
   - Run R-peak detection (e.g., Pan-Tompkins or stationary wavelet transform) on the conditioned signal to determine beat centers.
   - Extract fixed-length windows (e.g., 300 samples) around each R-peak and normalize amplitude using previously exported scaling metadata.

4. **Wavelet tensor generation**
   - Invoke the deployed Python helper (`create_wavelet_tensors`) to convert the segmented beats into 64×300×3 scalograms (atrial, QRS, high-frequency channels).
   - Batch windows to maximize throughput when streaming to PL.

5. **Inference orchestration**
   - Use the provided Pynq runtime script to DMA batches into the `ecg_cnn_inference` IP and read back logits/probabilities.
   - Optionally fall back to the quantized TensorFlow Lite model on the ARM core when PL is idle or during debugging.

6. **Result handling and UX**
   - Smooth predictions over time (majority vote or hidden Markov models) to reduce jitter.
   - Expose results through:
     - REST API (Flask/FastAPI) serving JSON summaries.
     - Websocket stream for live dashboards (Plotly Dash, Bokeh, or Pynq Jupyter widgets).
     - Local storage (SQLite/CSV) for historical review and regulatory logging.

## 3. Programmable Logic Responsibilities

1. **Integrate the CNN IP**
   - Import the generated HLS project (`FPGA/hls_cnn`) into Vivado, synthesize, and package as an AXI-Stream or AXI-Lite peripheral.
   - Connect AXI interfaces to the Zynq PS via SmartConnect/AXI Interconnect and add AXI-DMA for high-throughput data movement.

2. **Memory-mapped control**
   - Expose registers for input buffer pointers, batch size, and start/done status so PS software can coordinate inference.
   - Use interrupts to notify the PS when classification results are ready.

3. **Fixed-point alignment**
   - Ensure the HLS data types (`ap_fixed<CNN_HLS_TOTAL_BITS, CNN_HLS_INTEGER_BITS>`) match the quantized export generated by `main.py`.
   - Validate numerical ranges using the exported min/max statistics to avoid overflow.

4. **Latency and throughput optimization**
   - Apply HLS pragmas (loop pipelining, array partitioning) to reach the desired sample rate (e.g., >250 inferences/s).
   - Profile resource usage (DSP, BRAM) and adjust unrolling factors accordingly.

## 4. Data Flow From Sensor to Classification Result

1. **Sampling**: The AFE streams digitized ECG samples (250–500 Hz) into PS memory via DMA.
2. **Preprocessing**: PS firmware filters noise and removes baseline wander.
3. **Segmentation**: R-peak detection yields beat-centered windows (approx. 300 samples).
4. **Feature construction**: Each window is transformed into a 64×300×3 wavelet tensor.
5. **Inference**: PS streams tensors to PL CNN IP; PL returns class probabilities.
6. **Post-processing**: PS applies smoothing, generates alerts (e.g., arrhythmia detection), and logs results.
7. **Visualization**: Web dashboard plots current waveform, highlighted arrhythmia labels, and statistics (precision, recall from training metadata).

## 5. Suggested Software Stack on PS

| Layer | Recommended Tools |
|-------|-------------------|
| OS | Pynq Linux (Ubuntu-based) |
| Driver / I/O | Python `pynq` library, custom C extensions for low-latency DMA |
| Preprocessing | `numpy`, `scipy`, `pywavelets` (already used during training) |
| Control Logic | `pynq.Overlay` for bitstream loading, `MMIO` for register access |
| API/UI | Flask/FastAPI + Plotly Dash, or lightweight Qt GUI |
| Monitoring | `systemd` service for background data acquisition, MQTT/REST for integration |

## 6. Front-End Product Ideas

- **Clinical dashboard**: Real-time strip with color-coded rhythm annotations, per-class confidence, and alarm banner.
- **Mobile companion**: Stream compressed results to a tablet/phone app for clinicians.
- **Analytics module**: Aggregate daily arrhythmia counts, generate PDF reports, and expose data for EMR integration.

## 7. Deployment Checklist

- [ ] Validate sensor interface and sampling integrity on PS.
- [ ] Confirm preprocessing pipeline matches training-time normalization.
- [ ] Load PL bitstream and verify loopback test with synthetic tensors.
- [ ] Run end-to-end test using recorded MIT-BIH segments to confirm parity with Python results.
- [ ] Harden services (auto-start, watchdog timers) for clinical reliability.
- [ ] Document cybersecurity and patient data handling (encryption, access control).

By following this blueprint, the Pynq-Z2 can support real-time ECG acquisition, robust preprocessing, CNN-based classification in hardware, and a production-ready user interface within a single integrated platform.
